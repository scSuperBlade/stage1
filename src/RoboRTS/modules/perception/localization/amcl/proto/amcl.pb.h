// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: amcl.proto

#ifndef PROTOBUF_amcl_2eproto__INCLUDED
#define PROTOBUF_amcl_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_amcl_2eproto();
void protobuf_AssignDesc_amcl_2eproto();
void protobuf_ShutdownFile_amcl_2eproto();

class AmclParam;

enum LaserModel {
  LASER_MODEL_BEAM = 0,
  LASER_MODEL_LIKELIHOOD_FIELD = 1,
  LASER_MODEL_LIKELIHOOD_FIELD_PROB = 2
};
bool LaserModel_IsValid(int value);
const LaserModel LaserModel_MIN = LASER_MODEL_BEAM;
const LaserModel LaserModel_MAX = LASER_MODEL_LIKELIHOOD_FIELD_PROB;
const int LaserModel_ARRAYSIZE = LaserModel_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaserModel_descriptor();
inline const ::std::string& LaserModel_Name(LaserModel value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaserModel_descriptor(), value);
}
inline bool LaserModel_Parse(
    const ::std::string& name, LaserModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaserModel>(
    LaserModel_descriptor(), name, value);
}
enum OdomModel {
  ODOM_MODEL_DIFF = 0,
  ODOM_MODEL_OMNI = 1
};
bool OdomModel_IsValid(int value);
const OdomModel OdomModel_MIN = ODOM_MODEL_DIFF;
const OdomModel OdomModel_MAX = ODOM_MODEL_OMNI;
const int OdomModel_ARRAYSIZE = OdomModel_MAX + 1;

const ::google::protobuf::EnumDescriptor* OdomModel_descriptor();
inline const ::std::string& OdomModel_Name(OdomModel value) {
  return ::google::protobuf::internal::NameOfEnum(
    OdomModel_descriptor(), value);
}
inline bool OdomModel_Parse(
    const ::std::string& name, OdomModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OdomModel>(
    OdomModel_descriptor(), name, value);
}
// ===================================================================

class AmclParam : public ::google::protobuf::Message {
 public:
  AmclParam();
  virtual ~AmclParam();

  AmclParam(const AmclParam& from);

  inline AmclParam& operator=(const AmclParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AmclParam& default_instance();

  void Swap(AmclParam* other);

  // implements Message ----------------------------------------------

  AmclParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AmclParam& from);
  void MergeFrom(const AmclParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool use_map_topic = 1 [default = false];
  inline bool has_use_map_topic() const;
  inline void clear_use_map_topic();
  static const int kUseMapTopicFieldNumber = 1;
  inline bool use_map_topic() const;
  inline void set_use_map_topic(bool value);

  // required bool first_map_only = 2 [default = false];
  inline bool has_first_map_only() const;
  inline void clear_first_map_only();
  static const int kFirstMapOnlyFieldNumber = 2;
  inline bool first_map_only() const;
  inline void set_first_map_only(bool value);

  // required int32 gui_publish_rate = 3 [default = 10];
  inline bool has_gui_publish_rate() const;
  inline void clear_gui_publish_rate();
  static const int kGuiPublishRateFieldNumber = 3;
  inline ::google::protobuf::int32 gui_publish_rate() const;
  inline void set_gui_publish_rate(::google::protobuf::int32 value);

  // optional double laser_min_range = 4 [default = 0.15];
  inline bool has_laser_min_range() const;
  inline void clear_laser_min_range();
  static const int kLaserMinRangeFieldNumber = 4;
  inline double laser_min_range() const;
  inline void set_laser_min_range(double value);

  // optional double laser_max_range = 5 [default = 8];
  inline bool has_laser_max_range() const;
  inline void clear_laser_max_range();
  static const int kLaserMaxRangeFieldNumber = 5;
  inline double laser_max_range() const;
  inline void set_laser_max_range(double value);

  // optional int32 laser_max_beams = 6 [default = 30];
  inline bool has_laser_max_beams() const;
  inline void clear_laser_max_beams();
  static const int kLaserMaxBeamsFieldNumber = 6;
  inline ::google::protobuf::int32 laser_max_beams() const;
  inline void set_laser_max_beams(::google::protobuf::int32 value);

  // required int32 min_particles = 7 [default = 500];
  inline bool has_min_particles() const;
  inline void clear_min_particles();
  static const int kMinParticlesFieldNumber = 7;
  inline ::google::protobuf::int32 min_particles() const;
  inline void set_min_particles(::google::protobuf::int32 value);

  // required int32 max_particles = 8 [default = 5000];
  inline bool has_max_particles() const;
  inline void clear_max_particles();
  static const int kMaxParticlesFieldNumber = 8;
  inline ::google::protobuf::int32 max_particles() const;
  inline void set_max_particles(::google::protobuf::int32 value);

  // required double kld_err = 9 [default = 0.05];
  inline bool has_kld_err() const;
  inline void clear_kld_err();
  static const int kKldErrFieldNumber = 9;
  inline double kld_err() const;
  inline void set_kld_err(double value);

  // required double kld_z = 10 [default = 0.99];
  inline bool has_kld_z() const;
  inline void clear_kld_z();
  static const int kKldZFieldNumber = 10;
  inline double kld_z() const;
  inline void set_kld_z(double value);

  // required .LaserModel laser_model = 11 [default = LASER_MODEL_LIKELIHOOD_FIELD_PROB];
  inline bool has_laser_model() const;
  inline void clear_laser_model();
  static const int kLaserModelFieldNumber = 11;
  inline ::LaserModel laser_model() const;
  inline void set_laser_model(::LaserModel value);

  // required double z_hit = 12 [default = 0.5];
  inline bool has_z_hit() const;
  inline void clear_z_hit();
  static const int kZHitFieldNumber = 12;
  inline double z_hit() const;
  inline void set_z_hit(double value);

  // required double z_rand = 13 [default = 0.5];
  inline bool has_z_rand() const;
  inline void clear_z_rand();
  static const int kZRandFieldNumber = 13;
  inline double z_rand() const;
  inline void set_z_rand(double value);

  // required double sigma_hit = 14 [default = 0.2];
  inline bool has_sigma_hit() const;
  inline void clear_sigma_hit();
  static const int kSigmaHitFieldNumber = 14;
  inline double sigma_hit() const;
  inline void set_sigma_hit(double value);

  // required double lambda_short = 15 [default = 0.1];
  inline bool has_lambda_short() const;
  inline void clear_lambda_short();
  static const int kLambdaShortFieldNumber = 15;
  inline double lambda_short() const;
  inline void set_lambda_short(double value);

  // required double laser_likelihood_max_dist = 16 [default = 2];
  inline bool has_laser_likelihood_max_dist() const;
  inline void clear_laser_likelihood_max_dist();
  static const int kLaserLikelihoodMaxDistFieldNumber = 16;
  inline double laser_likelihood_max_dist() const;
  inline void set_laser_likelihood_max_dist(double value);

  // required bool do_beamskip = 17 [default = true];
  inline bool has_do_beamskip() const;
  inline void clear_do_beamskip();
  static const int kDoBeamskipFieldNumber = 17;
  inline bool do_beamskip() const;
  inline void set_do_beamskip(bool value);

  // required double beam_skip_distance = 18 [default = 0.5];
  inline bool has_beam_skip_distance() const;
  inline void clear_beam_skip_distance();
  static const int kBeamSkipDistanceFieldNumber = 18;
  inline double beam_skip_distance() const;
  inline void set_beam_skip_distance(double value);

  // required double beam_skip_threshold = 19 [default = 0.3];
  inline bool has_beam_skip_threshold() const;
  inline void clear_beam_skip_threshold();
  static const int kBeamSkipThresholdFieldNumber = 19;
  inline double beam_skip_threshold() const;
  inline void set_beam_skip_threshold(double value);

  // required double beam_skip_error_threshold = 20 [default = 0.9];
  inline bool has_beam_skip_error_threshold() const;
  inline void clear_beam_skip_error_threshold();
  static const int kBeamSkipErrorThresholdFieldNumber = 20;
  inline double beam_skip_error_threshold() const;
  inline void set_beam_skip_error_threshold(double value);

  // required .OdomModel odom_model = 21 [default = ODOM_MODEL_OMNI];
  inline bool has_odom_model() const;
  inline void clear_odom_model();
  static const int kOdomModelFieldNumber = 21;
  inline ::OdomModel odom_model() const;
  inline void set_odom_model(::OdomModel value);

  // required double odom_alpha1 = 22 [default = 0.005];
  inline bool has_odom_alpha1() const;
  inline void clear_odom_alpha1();
  static const int kOdomAlpha1FieldNumber = 22;
  inline double odom_alpha1() const;
  inline void set_odom_alpha1(double value);

  // required double odom_alpha2 = 23 [default = 0.005];
  inline bool has_odom_alpha2() const;
  inline void clear_odom_alpha2();
  static const int kOdomAlpha2FieldNumber = 23;
  inline double odom_alpha2() const;
  inline void set_odom_alpha2(double value);

  // required double odom_alpha3 = 24 [default = 0.01];
  inline bool has_odom_alpha3() const;
  inline void clear_odom_alpha3();
  static const int kOdomAlpha3FieldNumber = 24;
  inline double odom_alpha3() const;
  inline void set_odom_alpha3(double value);

  // required double odom_alpha4 = 25 [default = 0.005];
  inline bool has_odom_alpha4() const;
  inline void clear_odom_alpha4();
  static const int kOdomAlpha4FieldNumber = 25;
  inline double odom_alpha4() const;
  inline void set_odom_alpha4(double value);

  // required double odom_alpha5 = 26 [default = 0.003];
  inline bool has_odom_alpha5() const;
  inline void clear_odom_alpha5();
  static const int kOdomAlpha5FieldNumber = 26;
  inline double odom_alpha5() const;
  inline void set_odom_alpha5(double value);

  // required double update_min_d = 27 [default = 0.2];
  inline bool has_update_min_d() const;
  inline void clear_update_min_d();
  static const int kUpdateMinDFieldNumber = 27;
  inline double update_min_d() const;
  inline void set_update_min_d(double value);

  // required double update_min_a = 28 [default = 0.5];
  inline bool has_update_min_a() const;
  inline void clear_update_min_a();
  static const int kUpdateMinAFieldNumber = 28;
  inline double update_min_a() const;
  inline void set_update_min_a(double value);

  // required int32 resample_interval = 32 [default = 1];
  inline bool has_resample_interval() const;
  inline void clear_resample_interval();
  static const int kResampleIntervalFieldNumber = 32;
  inline ::google::protobuf::int32 resample_interval() const;
  inline void set_resample_interval(::google::protobuf::int32 value);

  // required double transform_tolerance = 33 [default = 0.1];
  inline bool has_transform_tolerance() const;
  inline void clear_transform_tolerance();
  static const int kTransformToleranceFieldNumber = 33;
  inline double transform_tolerance() const;
  inline void set_transform_tolerance(double value);

  // required double recovery_alpha_slow = 34 [default = 0.001];
  inline bool has_recovery_alpha_slow() const;
  inline void clear_recovery_alpha_slow();
  static const int kRecoveryAlphaSlowFieldNumber = 34;
  inline double recovery_alpha_slow() const;
  inline void set_recovery_alpha_slow(double value);

  // required double recovery_alpha_fast = 35 [default = 0.1];
  inline bool has_recovery_alpha_fast() const;
  inline void clear_recovery_alpha_fast();
  static const int kRecoveryAlphaFastFieldNumber = 35;
  inline double recovery_alpha_fast() const;
  inline void set_recovery_alpha_fast(double value);

  // required bool use_global_localization = 42 [default = true];
  inline bool has_use_global_localization() const;
  inline void clear_use_global_localization();
  static const int kUseGlobalLocalizationFieldNumber = 42;
  inline bool use_global_localization() const;
  inline void set_use_global_localization(bool value);

  // required double laser_filter_weight = 43 [default = 0.05];
  inline bool has_laser_filter_weight() const;
  inline void clear_laser_filter_weight();
  static const int kLaserFilterWeightFieldNumber = 43;
  inline double laser_filter_weight() const;
  inline void set_laser_filter_weight(double value);

  // optional int32 max_uwb_particles = 51 [default = 10];
  inline bool has_max_uwb_particles() const;
  inline void clear_max_uwb_particles();
  static const int kMaxUwbParticlesFieldNumber = 51;
  inline ::google::protobuf::int32 max_uwb_particles() const;
  inline void set_max_uwb_particles(::google::protobuf::int32 value);

  // optional double uwb_cov_x = 52 [default = 0.09];
  inline bool has_uwb_cov_x() const;
  inline void clear_uwb_cov_x();
  static const int kUwbCovXFieldNumber = 52;
  inline double uwb_cov_x() const;
  inline void set_uwb_cov_x(double value);

  // optional double uwb_cov_y = 53 [default = 0.09];
  inline bool has_uwb_cov_y() const;
  inline void clear_uwb_cov_y();
  static const int kUwbCovYFieldNumber = 53;
  inline double uwb_cov_y() const;
  inline void set_uwb_cov_y(double value);

  // optional double resample_uwb_factor = 54 [default = 3];
  inline bool has_resample_uwb_factor() const;
  inline void clear_resample_uwb_factor();
  static const int kResampleUwbFactorFieldNumber = 54;
  inline double resample_uwb_factor() const;
  inline void set_resample_uwb_factor(double value);

  // @@protoc_insertion_point(class_scope:AmclParam)
 private:
  inline void set_has_use_map_topic();
  inline void clear_has_use_map_topic();
  inline void set_has_first_map_only();
  inline void clear_has_first_map_only();
  inline void set_has_gui_publish_rate();
  inline void clear_has_gui_publish_rate();
  inline void set_has_laser_min_range();
  inline void clear_has_laser_min_range();
  inline void set_has_laser_max_range();
  inline void clear_has_laser_max_range();
  inline void set_has_laser_max_beams();
  inline void clear_has_laser_max_beams();
  inline void set_has_min_particles();
  inline void clear_has_min_particles();
  inline void set_has_max_particles();
  inline void clear_has_max_particles();
  inline void set_has_kld_err();
  inline void clear_has_kld_err();
  inline void set_has_kld_z();
  inline void clear_has_kld_z();
  inline void set_has_laser_model();
  inline void clear_has_laser_model();
  inline void set_has_z_hit();
  inline void clear_has_z_hit();
  inline void set_has_z_rand();
  inline void clear_has_z_rand();
  inline void set_has_sigma_hit();
  inline void clear_has_sigma_hit();
  inline void set_has_lambda_short();
  inline void clear_has_lambda_short();
  inline void set_has_laser_likelihood_max_dist();
  inline void clear_has_laser_likelihood_max_dist();
  inline void set_has_do_beamskip();
  inline void clear_has_do_beamskip();
  inline void set_has_beam_skip_distance();
  inline void clear_has_beam_skip_distance();
  inline void set_has_beam_skip_threshold();
  inline void clear_has_beam_skip_threshold();
  inline void set_has_beam_skip_error_threshold();
  inline void clear_has_beam_skip_error_threshold();
  inline void set_has_odom_model();
  inline void clear_has_odom_model();
  inline void set_has_odom_alpha1();
  inline void clear_has_odom_alpha1();
  inline void set_has_odom_alpha2();
  inline void clear_has_odom_alpha2();
  inline void set_has_odom_alpha3();
  inline void clear_has_odom_alpha3();
  inline void set_has_odom_alpha4();
  inline void clear_has_odom_alpha4();
  inline void set_has_odom_alpha5();
  inline void clear_has_odom_alpha5();
  inline void set_has_update_min_d();
  inline void clear_has_update_min_d();
  inline void set_has_update_min_a();
  inline void clear_has_update_min_a();
  inline void set_has_resample_interval();
  inline void clear_has_resample_interval();
  inline void set_has_transform_tolerance();
  inline void clear_has_transform_tolerance();
  inline void set_has_recovery_alpha_slow();
  inline void clear_has_recovery_alpha_slow();
  inline void set_has_recovery_alpha_fast();
  inline void clear_has_recovery_alpha_fast();
  inline void set_has_use_global_localization();
  inline void clear_has_use_global_localization();
  inline void set_has_laser_filter_weight();
  inline void clear_has_laser_filter_weight();
  inline void set_has_max_uwb_particles();
  inline void clear_has_max_uwb_particles();
  inline void set_has_uwb_cov_x();
  inline void clear_has_uwb_cov_x();
  inline void set_has_uwb_cov_y();
  inline void clear_has_uwb_cov_y();
  inline void set_has_resample_uwb_factor();
  inline void clear_has_resample_uwb_factor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  double laser_min_range_;
  ::google::protobuf::int32 gui_publish_rate_;
  ::google::protobuf::int32 laser_max_beams_;
  double laser_max_range_;
  ::google::protobuf::int32 min_particles_;
  ::google::protobuf::int32 max_particles_;
  double kld_err_;
  double kld_z_;
  double z_hit_;
  int laser_model_;
  bool use_map_topic_;
  bool first_map_only_;
  bool do_beamskip_;
  bool use_global_localization_;
  double z_rand_;
  double sigma_hit_;
  double lambda_short_;
  double laser_likelihood_max_dist_;
  double beam_skip_distance_;
  double beam_skip_threshold_;
  double beam_skip_error_threshold_;
  double odom_alpha1_;
  double odom_alpha2_;
  double odom_alpha3_;
  double odom_alpha4_;
  int odom_model_;
  ::google::protobuf::int32 resample_interval_;
  double odom_alpha5_;
  double update_min_d_;
  double update_min_a_;
  double transform_tolerance_;
  double recovery_alpha_slow_;
  double recovery_alpha_fast_;
  double laser_filter_weight_;
  double uwb_cov_x_;
  double uwb_cov_y_;
  double resample_uwb_factor_;
  ::google::protobuf::int32 max_uwb_particles_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_amcl_2eproto();
  friend void protobuf_AssignDesc_amcl_2eproto();
  friend void protobuf_ShutdownFile_amcl_2eproto();

  void InitAsDefaultInstance();
  static AmclParam* default_instance_;
};
// ===================================================================


// ===================================================================

// AmclParam

// required bool use_map_topic = 1 [default = false];
inline bool AmclParam::has_use_map_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AmclParam::set_has_use_map_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AmclParam::clear_has_use_map_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AmclParam::clear_use_map_topic() {
  use_map_topic_ = false;
  clear_has_use_map_topic();
}
inline bool AmclParam::use_map_topic() const {
  // @@protoc_insertion_point(field_get:AmclParam.use_map_topic)
  return use_map_topic_;
}
inline void AmclParam::set_use_map_topic(bool value) {
  set_has_use_map_topic();
  use_map_topic_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.use_map_topic)
}

// required bool first_map_only = 2 [default = false];
inline bool AmclParam::has_first_map_only() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AmclParam::set_has_first_map_only() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AmclParam::clear_has_first_map_only() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AmclParam::clear_first_map_only() {
  first_map_only_ = false;
  clear_has_first_map_only();
}
inline bool AmclParam::first_map_only() const {
  // @@protoc_insertion_point(field_get:AmclParam.first_map_only)
  return first_map_only_;
}
inline void AmclParam::set_first_map_only(bool value) {
  set_has_first_map_only();
  first_map_only_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.first_map_only)
}

// required int32 gui_publish_rate = 3 [default = 10];
inline bool AmclParam::has_gui_publish_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AmclParam::set_has_gui_publish_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AmclParam::clear_has_gui_publish_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AmclParam::clear_gui_publish_rate() {
  gui_publish_rate_ = 10;
  clear_has_gui_publish_rate();
}
inline ::google::protobuf::int32 AmclParam::gui_publish_rate() const {
  // @@protoc_insertion_point(field_get:AmclParam.gui_publish_rate)
  return gui_publish_rate_;
}
inline void AmclParam::set_gui_publish_rate(::google::protobuf::int32 value) {
  set_has_gui_publish_rate();
  gui_publish_rate_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.gui_publish_rate)
}

// optional double laser_min_range = 4 [default = 0.15];
inline bool AmclParam::has_laser_min_range() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AmclParam::set_has_laser_min_range() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AmclParam::clear_has_laser_min_range() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AmclParam::clear_laser_min_range() {
  laser_min_range_ = 0.15;
  clear_has_laser_min_range();
}
inline double AmclParam::laser_min_range() const {
  // @@protoc_insertion_point(field_get:AmclParam.laser_min_range)
  return laser_min_range_;
}
inline void AmclParam::set_laser_min_range(double value) {
  set_has_laser_min_range();
  laser_min_range_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.laser_min_range)
}

// optional double laser_max_range = 5 [default = 8];
inline bool AmclParam::has_laser_max_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AmclParam::set_has_laser_max_range() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AmclParam::clear_has_laser_max_range() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AmclParam::clear_laser_max_range() {
  laser_max_range_ = 8;
  clear_has_laser_max_range();
}
inline double AmclParam::laser_max_range() const {
  // @@protoc_insertion_point(field_get:AmclParam.laser_max_range)
  return laser_max_range_;
}
inline void AmclParam::set_laser_max_range(double value) {
  set_has_laser_max_range();
  laser_max_range_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.laser_max_range)
}

// optional int32 laser_max_beams = 6 [default = 30];
inline bool AmclParam::has_laser_max_beams() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AmclParam::set_has_laser_max_beams() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AmclParam::clear_has_laser_max_beams() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AmclParam::clear_laser_max_beams() {
  laser_max_beams_ = 30;
  clear_has_laser_max_beams();
}
inline ::google::protobuf::int32 AmclParam::laser_max_beams() const {
  // @@protoc_insertion_point(field_get:AmclParam.laser_max_beams)
  return laser_max_beams_;
}
inline void AmclParam::set_laser_max_beams(::google::protobuf::int32 value) {
  set_has_laser_max_beams();
  laser_max_beams_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.laser_max_beams)
}

// required int32 min_particles = 7 [default = 500];
inline bool AmclParam::has_min_particles() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AmclParam::set_has_min_particles() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AmclParam::clear_has_min_particles() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AmclParam::clear_min_particles() {
  min_particles_ = 500;
  clear_has_min_particles();
}
inline ::google::protobuf::int32 AmclParam::min_particles() const {
  // @@protoc_insertion_point(field_get:AmclParam.min_particles)
  return min_particles_;
}
inline void AmclParam::set_min_particles(::google::protobuf::int32 value) {
  set_has_min_particles();
  min_particles_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.min_particles)
}

// required int32 max_particles = 8 [default = 5000];
inline bool AmclParam::has_max_particles() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AmclParam::set_has_max_particles() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AmclParam::clear_has_max_particles() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AmclParam::clear_max_particles() {
  max_particles_ = 5000;
  clear_has_max_particles();
}
inline ::google::protobuf::int32 AmclParam::max_particles() const {
  // @@protoc_insertion_point(field_get:AmclParam.max_particles)
  return max_particles_;
}
inline void AmclParam::set_max_particles(::google::protobuf::int32 value) {
  set_has_max_particles();
  max_particles_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.max_particles)
}

// required double kld_err = 9 [default = 0.05];
inline bool AmclParam::has_kld_err() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AmclParam::set_has_kld_err() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AmclParam::clear_has_kld_err() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AmclParam::clear_kld_err() {
  kld_err_ = 0.05;
  clear_has_kld_err();
}
inline double AmclParam::kld_err() const {
  // @@protoc_insertion_point(field_get:AmclParam.kld_err)
  return kld_err_;
}
inline void AmclParam::set_kld_err(double value) {
  set_has_kld_err();
  kld_err_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.kld_err)
}

// required double kld_z = 10 [default = 0.99];
inline bool AmclParam::has_kld_z() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AmclParam::set_has_kld_z() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AmclParam::clear_has_kld_z() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AmclParam::clear_kld_z() {
  kld_z_ = 0.99;
  clear_has_kld_z();
}
inline double AmclParam::kld_z() const {
  // @@protoc_insertion_point(field_get:AmclParam.kld_z)
  return kld_z_;
}
inline void AmclParam::set_kld_z(double value) {
  set_has_kld_z();
  kld_z_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.kld_z)
}

// required .LaserModel laser_model = 11 [default = LASER_MODEL_LIKELIHOOD_FIELD_PROB];
inline bool AmclParam::has_laser_model() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AmclParam::set_has_laser_model() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AmclParam::clear_has_laser_model() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AmclParam::clear_laser_model() {
  laser_model_ = 2;
  clear_has_laser_model();
}
inline ::LaserModel AmclParam::laser_model() const {
  // @@protoc_insertion_point(field_get:AmclParam.laser_model)
  return static_cast< ::LaserModel >(laser_model_);
}
inline void AmclParam::set_laser_model(::LaserModel value) {
  assert(::LaserModel_IsValid(value));
  set_has_laser_model();
  laser_model_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.laser_model)
}

// required double z_hit = 12 [default = 0.5];
inline bool AmclParam::has_z_hit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AmclParam::set_has_z_hit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AmclParam::clear_has_z_hit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AmclParam::clear_z_hit() {
  z_hit_ = 0.5;
  clear_has_z_hit();
}
inline double AmclParam::z_hit() const {
  // @@protoc_insertion_point(field_get:AmclParam.z_hit)
  return z_hit_;
}
inline void AmclParam::set_z_hit(double value) {
  set_has_z_hit();
  z_hit_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.z_hit)
}

// required double z_rand = 13 [default = 0.5];
inline bool AmclParam::has_z_rand() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AmclParam::set_has_z_rand() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AmclParam::clear_has_z_rand() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AmclParam::clear_z_rand() {
  z_rand_ = 0.5;
  clear_has_z_rand();
}
inline double AmclParam::z_rand() const {
  // @@protoc_insertion_point(field_get:AmclParam.z_rand)
  return z_rand_;
}
inline void AmclParam::set_z_rand(double value) {
  set_has_z_rand();
  z_rand_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.z_rand)
}

// required double sigma_hit = 14 [default = 0.2];
inline bool AmclParam::has_sigma_hit() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AmclParam::set_has_sigma_hit() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AmclParam::clear_has_sigma_hit() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AmclParam::clear_sigma_hit() {
  sigma_hit_ = 0.2;
  clear_has_sigma_hit();
}
inline double AmclParam::sigma_hit() const {
  // @@protoc_insertion_point(field_get:AmclParam.sigma_hit)
  return sigma_hit_;
}
inline void AmclParam::set_sigma_hit(double value) {
  set_has_sigma_hit();
  sigma_hit_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.sigma_hit)
}

// required double lambda_short = 15 [default = 0.1];
inline bool AmclParam::has_lambda_short() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AmclParam::set_has_lambda_short() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AmclParam::clear_has_lambda_short() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AmclParam::clear_lambda_short() {
  lambda_short_ = 0.1;
  clear_has_lambda_short();
}
inline double AmclParam::lambda_short() const {
  // @@protoc_insertion_point(field_get:AmclParam.lambda_short)
  return lambda_short_;
}
inline void AmclParam::set_lambda_short(double value) {
  set_has_lambda_short();
  lambda_short_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.lambda_short)
}

// required double laser_likelihood_max_dist = 16 [default = 2];
inline bool AmclParam::has_laser_likelihood_max_dist() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AmclParam::set_has_laser_likelihood_max_dist() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AmclParam::clear_has_laser_likelihood_max_dist() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AmclParam::clear_laser_likelihood_max_dist() {
  laser_likelihood_max_dist_ = 2;
  clear_has_laser_likelihood_max_dist();
}
inline double AmclParam::laser_likelihood_max_dist() const {
  // @@protoc_insertion_point(field_get:AmclParam.laser_likelihood_max_dist)
  return laser_likelihood_max_dist_;
}
inline void AmclParam::set_laser_likelihood_max_dist(double value) {
  set_has_laser_likelihood_max_dist();
  laser_likelihood_max_dist_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.laser_likelihood_max_dist)
}

// required bool do_beamskip = 17 [default = true];
inline bool AmclParam::has_do_beamskip() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AmclParam::set_has_do_beamskip() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AmclParam::clear_has_do_beamskip() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AmclParam::clear_do_beamskip() {
  do_beamskip_ = true;
  clear_has_do_beamskip();
}
inline bool AmclParam::do_beamskip() const {
  // @@protoc_insertion_point(field_get:AmclParam.do_beamskip)
  return do_beamskip_;
}
inline void AmclParam::set_do_beamskip(bool value) {
  set_has_do_beamskip();
  do_beamskip_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.do_beamskip)
}

// required double beam_skip_distance = 18 [default = 0.5];
inline bool AmclParam::has_beam_skip_distance() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AmclParam::set_has_beam_skip_distance() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AmclParam::clear_has_beam_skip_distance() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AmclParam::clear_beam_skip_distance() {
  beam_skip_distance_ = 0.5;
  clear_has_beam_skip_distance();
}
inline double AmclParam::beam_skip_distance() const {
  // @@protoc_insertion_point(field_get:AmclParam.beam_skip_distance)
  return beam_skip_distance_;
}
inline void AmclParam::set_beam_skip_distance(double value) {
  set_has_beam_skip_distance();
  beam_skip_distance_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.beam_skip_distance)
}

// required double beam_skip_threshold = 19 [default = 0.3];
inline bool AmclParam::has_beam_skip_threshold() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AmclParam::set_has_beam_skip_threshold() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AmclParam::clear_has_beam_skip_threshold() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AmclParam::clear_beam_skip_threshold() {
  beam_skip_threshold_ = 0.3;
  clear_has_beam_skip_threshold();
}
inline double AmclParam::beam_skip_threshold() const {
  // @@protoc_insertion_point(field_get:AmclParam.beam_skip_threshold)
  return beam_skip_threshold_;
}
inline void AmclParam::set_beam_skip_threshold(double value) {
  set_has_beam_skip_threshold();
  beam_skip_threshold_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.beam_skip_threshold)
}

// required double beam_skip_error_threshold = 20 [default = 0.9];
inline bool AmclParam::has_beam_skip_error_threshold() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AmclParam::set_has_beam_skip_error_threshold() {
  _has_bits_[0] |= 0x00080000u;
}
inline void AmclParam::clear_has_beam_skip_error_threshold() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void AmclParam::clear_beam_skip_error_threshold() {
  beam_skip_error_threshold_ = 0.9;
  clear_has_beam_skip_error_threshold();
}
inline double AmclParam::beam_skip_error_threshold() const {
  // @@protoc_insertion_point(field_get:AmclParam.beam_skip_error_threshold)
  return beam_skip_error_threshold_;
}
inline void AmclParam::set_beam_skip_error_threshold(double value) {
  set_has_beam_skip_error_threshold();
  beam_skip_error_threshold_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.beam_skip_error_threshold)
}

// required .OdomModel odom_model = 21 [default = ODOM_MODEL_OMNI];
inline bool AmclParam::has_odom_model() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AmclParam::set_has_odom_model() {
  _has_bits_[0] |= 0x00100000u;
}
inline void AmclParam::clear_has_odom_model() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void AmclParam::clear_odom_model() {
  odom_model_ = 1;
  clear_has_odom_model();
}
inline ::OdomModel AmclParam::odom_model() const {
  // @@protoc_insertion_point(field_get:AmclParam.odom_model)
  return static_cast< ::OdomModel >(odom_model_);
}
inline void AmclParam::set_odom_model(::OdomModel value) {
  assert(::OdomModel_IsValid(value));
  set_has_odom_model();
  odom_model_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.odom_model)
}

// required double odom_alpha1 = 22 [default = 0.005];
inline bool AmclParam::has_odom_alpha1() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AmclParam::set_has_odom_alpha1() {
  _has_bits_[0] |= 0x00200000u;
}
inline void AmclParam::clear_has_odom_alpha1() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void AmclParam::clear_odom_alpha1() {
  odom_alpha1_ = 0.005;
  clear_has_odom_alpha1();
}
inline double AmclParam::odom_alpha1() const {
  // @@protoc_insertion_point(field_get:AmclParam.odom_alpha1)
  return odom_alpha1_;
}
inline void AmclParam::set_odom_alpha1(double value) {
  set_has_odom_alpha1();
  odom_alpha1_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.odom_alpha1)
}

// required double odom_alpha2 = 23 [default = 0.005];
inline bool AmclParam::has_odom_alpha2() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AmclParam::set_has_odom_alpha2() {
  _has_bits_[0] |= 0x00400000u;
}
inline void AmclParam::clear_has_odom_alpha2() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void AmclParam::clear_odom_alpha2() {
  odom_alpha2_ = 0.005;
  clear_has_odom_alpha2();
}
inline double AmclParam::odom_alpha2() const {
  // @@protoc_insertion_point(field_get:AmclParam.odom_alpha2)
  return odom_alpha2_;
}
inline void AmclParam::set_odom_alpha2(double value) {
  set_has_odom_alpha2();
  odom_alpha2_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.odom_alpha2)
}

// required double odom_alpha3 = 24 [default = 0.01];
inline bool AmclParam::has_odom_alpha3() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void AmclParam::set_has_odom_alpha3() {
  _has_bits_[0] |= 0x00800000u;
}
inline void AmclParam::clear_has_odom_alpha3() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void AmclParam::clear_odom_alpha3() {
  odom_alpha3_ = 0.01;
  clear_has_odom_alpha3();
}
inline double AmclParam::odom_alpha3() const {
  // @@protoc_insertion_point(field_get:AmclParam.odom_alpha3)
  return odom_alpha3_;
}
inline void AmclParam::set_odom_alpha3(double value) {
  set_has_odom_alpha3();
  odom_alpha3_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.odom_alpha3)
}

// required double odom_alpha4 = 25 [default = 0.005];
inline bool AmclParam::has_odom_alpha4() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void AmclParam::set_has_odom_alpha4() {
  _has_bits_[0] |= 0x01000000u;
}
inline void AmclParam::clear_has_odom_alpha4() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void AmclParam::clear_odom_alpha4() {
  odom_alpha4_ = 0.005;
  clear_has_odom_alpha4();
}
inline double AmclParam::odom_alpha4() const {
  // @@protoc_insertion_point(field_get:AmclParam.odom_alpha4)
  return odom_alpha4_;
}
inline void AmclParam::set_odom_alpha4(double value) {
  set_has_odom_alpha4();
  odom_alpha4_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.odom_alpha4)
}

// required double odom_alpha5 = 26 [default = 0.003];
inline bool AmclParam::has_odom_alpha5() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AmclParam::set_has_odom_alpha5() {
  _has_bits_[0] |= 0x02000000u;
}
inline void AmclParam::clear_has_odom_alpha5() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void AmclParam::clear_odom_alpha5() {
  odom_alpha5_ = 0.003;
  clear_has_odom_alpha5();
}
inline double AmclParam::odom_alpha5() const {
  // @@protoc_insertion_point(field_get:AmclParam.odom_alpha5)
  return odom_alpha5_;
}
inline void AmclParam::set_odom_alpha5(double value) {
  set_has_odom_alpha5();
  odom_alpha5_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.odom_alpha5)
}

// required double update_min_d = 27 [default = 0.2];
inline bool AmclParam::has_update_min_d() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void AmclParam::set_has_update_min_d() {
  _has_bits_[0] |= 0x04000000u;
}
inline void AmclParam::clear_has_update_min_d() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void AmclParam::clear_update_min_d() {
  update_min_d_ = 0.2;
  clear_has_update_min_d();
}
inline double AmclParam::update_min_d() const {
  // @@protoc_insertion_point(field_get:AmclParam.update_min_d)
  return update_min_d_;
}
inline void AmclParam::set_update_min_d(double value) {
  set_has_update_min_d();
  update_min_d_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.update_min_d)
}

// required double update_min_a = 28 [default = 0.5];
inline bool AmclParam::has_update_min_a() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void AmclParam::set_has_update_min_a() {
  _has_bits_[0] |= 0x08000000u;
}
inline void AmclParam::clear_has_update_min_a() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void AmclParam::clear_update_min_a() {
  update_min_a_ = 0.5;
  clear_has_update_min_a();
}
inline double AmclParam::update_min_a() const {
  // @@protoc_insertion_point(field_get:AmclParam.update_min_a)
  return update_min_a_;
}
inline void AmclParam::set_update_min_a(double value) {
  set_has_update_min_a();
  update_min_a_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.update_min_a)
}

// required int32 resample_interval = 32 [default = 1];
inline bool AmclParam::has_resample_interval() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void AmclParam::set_has_resample_interval() {
  _has_bits_[0] |= 0x10000000u;
}
inline void AmclParam::clear_has_resample_interval() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void AmclParam::clear_resample_interval() {
  resample_interval_ = 1;
  clear_has_resample_interval();
}
inline ::google::protobuf::int32 AmclParam::resample_interval() const {
  // @@protoc_insertion_point(field_get:AmclParam.resample_interval)
  return resample_interval_;
}
inline void AmclParam::set_resample_interval(::google::protobuf::int32 value) {
  set_has_resample_interval();
  resample_interval_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.resample_interval)
}

// required double transform_tolerance = 33 [default = 0.1];
inline bool AmclParam::has_transform_tolerance() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void AmclParam::set_has_transform_tolerance() {
  _has_bits_[0] |= 0x20000000u;
}
inline void AmclParam::clear_has_transform_tolerance() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void AmclParam::clear_transform_tolerance() {
  transform_tolerance_ = 0.1;
  clear_has_transform_tolerance();
}
inline double AmclParam::transform_tolerance() const {
  // @@protoc_insertion_point(field_get:AmclParam.transform_tolerance)
  return transform_tolerance_;
}
inline void AmclParam::set_transform_tolerance(double value) {
  set_has_transform_tolerance();
  transform_tolerance_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.transform_tolerance)
}

// required double recovery_alpha_slow = 34 [default = 0.001];
inline bool AmclParam::has_recovery_alpha_slow() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void AmclParam::set_has_recovery_alpha_slow() {
  _has_bits_[0] |= 0x40000000u;
}
inline void AmclParam::clear_has_recovery_alpha_slow() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void AmclParam::clear_recovery_alpha_slow() {
  recovery_alpha_slow_ = 0.001;
  clear_has_recovery_alpha_slow();
}
inline double AmclParam::recovery_alpha_slow() const {
  // @@protoc_insertion_point(field_get:AmclParam.recovery_alpha_slow)
  return recovery_alpha_slow_;
}
inline void AmclParam::set_recovery_alpha_slow(double value) {
  set_has_recovery_alpha_slow();
  recovery_alpha_slow_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.recovery_alpha_slow)
}

// required double recovery_alpha_fast = 35 [default = 0.1];
inline bool AmclParam::has_recovery_alpha_fast() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void AmclParam::set_has_recovery_alpha_fast() {
  _has_bits_[0] |= 0x80000000u;
}
inline void AmclParam::clear_has_recovery_alpha_fast() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void AmclParam::clear_recovery_alpha_fast() {
  recovery_alpha_fast_ = 0.1;
  clear_has_recovery_alpha_fast();
}
inline double AmclParam::recovery_alpha_fast() const {
  // @@protoc_insertion_point(field_get:AmclParam.recovery_alpha_fast)
  return recovery_alpha_fast_;
}
inline void AmclParam::set_recovery_alpha_fast(double value) {
  set_has_recovery_alpha_fast();
  recovery_alpha_fast_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.recovery_alpha_fast)
}

// required bool use_global_localization = 42 [default = true];
inline bool AmclParam::has_use_global_localization() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void AmclParam::set_has_use_global_localization() {
  _has_bits_[1] |= 0x00000001u;
}
inline void AmclParam::clear_has_use_global_localization() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void AmclParam::clear_use_global_localization() {
  use_global_localization_ = true;
  clear_has_use_global_localization();
}
inline bool AmclParam::use_global_localization() const {
  // @@protoc_insertion_point(field_get:AmclParam.use_global_localization)
  return use_global_localization_;
}
inline void AmclParam::set_use_global_localization(bool value) {
  set_has_use_global_localization();
  use_global_localization_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.use_global_localization)
}

// required double laser_filter_weight = 43 [default = 0.05];
inline bool AmclParam::has_laser_filter_weight() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void AmclParam::set_has_laser_filter_weight() {
  _has_bits_[1] |= 0x00000002u;
}
inline void AmclParam::clear_has_laser_filter_weight() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void AmclParam::clear_laser_filter_weight() {
  laser_filter_weight_ = 0.05;
  clear_has_laser_filter_weight();
}
inline double AmclParam::laser_filter_weight() const {
  // @@protoc_insertion_point(field_get:AmclParam.laser_filter_weight)
  return laser_filter_weight_;
}
inline void AmclParam::set_laser_filter_weight(double value) {
  set_has_laser_filter_weight();
  laser_filter_weight_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.laser_filter_weight)
}

// optional int32 max_uwb_particles = 51 [default = 10];
inline bool AmclParam::has_max_uwb_particles() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void AmclParam::set_has_max_uwb_particles() {
  _has_bits_[1] |= 0x00000004u;
}
inline void AmclParam::clear_has_max_uwb_particles() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void AmclParam::clear_max_uwb_particles() {
  max_uwb_particles_ = 10;
  clear_has_max_uwb_particles();
}
inline ::google::protobuf::int32 AmclParam::max_uwb_particles() const {
  // @@protoc_insertion_point(field_get:AmclParam.max_uwb_particles)
  return max_uwb_particles_;
}
inline void AmclParam::set_max_uwb_particles(::google::protobuf::int32 value) {
  set_has_max_uwb_particles();
  max_uwb_particles_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.max_uwb_particles)
}

// optional double uwb_cov_x = 52 [default = 0.09];
inline bool AmclParam::has_uwb_cov_x() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void AmclParam::set_has_uwb_cov_x() {
  _has_bits_[1] |= 0x00000008u;
}
inline void AmclParam::clear_has_uwb_cov_x() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void AmclParam::clear_uwb_cov_x() {
  uwb_cov_x_ = 0.09;
  clear_has_uwb_cov_x();
}
inline double AmclParam::uwb_cov_x() const {
  // @@protoc_insertion_point(field_get:AmclParam.uwb_cov_x)
  return uwb_cov_x_;
}
inline void AmclParam::set_uwb_cov_x(double value) {
  set_has_uwb_cov_x();
  uwb_cov_x_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.uwb_cov_x)
}

// optional double uwb_cov_y = 53 [default = 0.09];
inline bool AmclParam::has_uwb_cov_y() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void AmclParam::set_has_uwb_cov_y() {
  _has_bits_[1] |= 0x00000010u;
}
inline void AmclParam::clear_has_uwb_cov_y() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void AmclParam::clear_uwb_cov_y() {
  uwb_cov_y_ = 0.09;
  clear_has_uwb_cov_y();
}
inline double AmclParam::uwb_cov_y() const {
  // @@protoc_insertion_point(field_get:AmclParam.uwb_cov_y)
  return uwb_cov_y_;
}
inline void AmclParam::set_uwb_cov_y(double value) {
  set_has_uwb_cov_y();
  uwb_cov_y_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.uwb_cov_y)
}

// optional double resample_uwb_factor = 54 [default = 3];
inline bool AmclParam::has_resample_uwb_factor() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void AmclParam::set_has_resample_uwb_factor() {
  _has_bits_[1] |= 0x00000020u;
}
inline void AmclParam::clear_has_resample_uwb_factor() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void AmclParam::clear_resample_uwb_factor() {
  resample_uwb_factor_ = 3;
  clear_has_resample_uwb_factor();
}
inline double AmclParam::resample_uwb_factor() const {
  // @@protoc_insertion_point(field_get:AmclParam.resample_uwb_factor)
  return resample_uwb_factor_;
}
inline void AmclParam::set_resample_uwb_factor(double value) {
  set_has_resample_uwb_factor();
  resample_uwb_factor_ = value;
  // @@protoc_insertion_point(field_set:AmclParam.resample_uwb_factor)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::LaserModel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LaserModel>() {
  return ::LaserModel_descriptor();
}
template <> struct is_proto_enum< ::OdomModel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OdomModel>() {
  return ::OdomModel_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_amcl_2eproto__INCLUDED
